epsilons = c(0, 0.05, 0.1, 0.2); # MUST BE 4 values as of right now.
maxHits = 100;
# ==============================================================================
# External Packages
library(ChemmineR)   # plotting mcs
library(fmcsR)       # computing mcs
library(MASS)        # performing mds
library(dbscan)      # performing db clustering
library(data.table)  # for creating data tables and storing results
# ==============================================================================
# Custom Functions
functions = list.files("Functions")
for(i in 1:length(functions)){
filename = paste0("Functions/",functions[i])
source(filename)
}
# ==============================================================================
# Reading in RDS Libraries
mainLib20 = readRDS("SearchLibraries/mainlib_20.RDS")
m20InChIKeys = mainLib20[which(mainLib20==">  <INCHIKEY>")+1]
m20NISTrn = mainLib20[which(mainLib20==">  <NISTNO>")+1]
m20entryEnds = which(mainLib20=="$$$$")
m20entryStarts = c(1,(m20entryEnds+1))
m20entryStarts = m20entryStarts[-length(m20entryStarts)]
swgdrug310 = readRDS("SearchLibraries/SWGDRUG310.RDS")
s310entryEnds = which(swgdrug310=="$$$$")
s310entryStarts = c(1,(s310entryEnds+1));
s310entryStarts = s310entryStarts[-length(s310entryStarts)]
s310InChIKeys = character(length(s310entryStarts))
for(i in 1:length(s310entryStarts)){
tempdata = swgdrug310[s310entryStarts[i]:s310entryEnds[i]]
a = which(tempdata==">  <INCHIKEY>")
if(length(a)>0){
s310InChIKeys[i] = tempdata[a+1]
}
}
# ==============================================================================
# Reading in Hit Lists for analysis
AllHitLists = readLines("Hitlists/HitList_search10.txt")
HitListCategories = strsplit(AllHitLists[4],"\t")[[1]]
AllHitLists = AllHitLists[5:(length(AllHitLists)-2)]
OrgHitLists = NULL
for(i in 1:length(AllHitLists)){
OrgHitLists = rbind(OrgHitLists,strsplit(AllHitLists[i],"\t")[[1]])
}
HitListStarts = which(OrgHitLists[,which(HitListCategories=="Rank")]==1)
HitListEnds = HitListStarts-1; HitListEnds = c(HitListEnds,length(AllHitLists));
HitListEnds = HitListEnds[-1]
## Main Script =================================================================
# The code can be broken into two parts. In the first section, given a hit list,
# we identify a potential core structure (if possible). In the second section,
# given a core structure and the analyte's known structure, we assess the quality
# of the predicted core structure.
# Section 1: Identifying potential core structure
numSearches = length(HitListStarts)
numEpsilons = length(epsilons)
Results = NULL
i = 1
HitList = OrgHitLists[HitListStarts[i]:HitListEnds[i],which(HitListCategories=="InChIKey")]
Scores = as.numeric(OrgHitLists[HitListStarts[i]:HitListEnds[i],which(HitListCategories=="MF")])
if(length(HitList)>maxHits){
HitList = HitList[1:maxHits]
}
HitListSDF = NULL;
for(j in 1:length(HitList)){
a = which(m20InChIKeys==HitList[j])[1]
m20sdf = mainLib20[m20entryStarts[a]:m20entryEnds[a]]
HitListSDF = c(HitListSDF,m20sdf)
}
hitlist = read.SDFset(HitListSDF)
plot(hitlist)
plot(hitlist)
plot(hitlist)
hitlist
plot(hitlist[[1]])
plot(hitlist[1:2])
plot(hitlist[1:10])
library("ChemmineR")
"ChemmineR" %in% installed.packages())
"ChemmineR" %in% installed.packages()
# ==============================================================================
# Reading in RDS Libraries
mainLib20 = readRDS("SearchLibraries/mainlib_20.RDS")
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
# Prototype code for identifying "core" structure from an
# MS Library search hit list. Code used for preparing ASMS results 2022 and
# working paper titled "Identifying the core structure of an analyte using
# ms library search results: a clustering-based approach" by Erisman & Moorthy.
#
# Developers:  EPE; edward.erisman@nist.gov
#              ASM; arun.moorthy@nist.gov
#
# Date: March 16th, 2022
# Revision Date: June 15th, 2022
# ==============================================================================
# Clear Work Space
rm(list=ls())
# USER INPUTS
epsilons = c(0, 0.05, 0.1, 0.2); # MUST BE 4 values as of right now. 0 results used in poster
maxHits = 100;
# ==============================================================================
# External Packages
# For Plotting SDF
if("ChemmineR" %in% installed.packages()==FALSE){
install.packages("ChemmineR")
library(ChemmineR)
} else {
library(ChemmineR)
}
# For computing MCS
if("fmcsR" %in% installed.packages()==FALSE){
install.packages("fmcsR")
library(fmcsR)
} else {
library(fmcsR)
}
# For performing db clustering
if("dbscan" %in% installed.packages()==FALSE){
install.packages("dbscan")
library(dbscan)
} else {
library(dbscan)
}
# For creating data tables and storing results
if("data.table" %in% installed.packages()==FALSE){
install.packages("data.table")
library(data.table)
} else {
library(data.table)
}
# ==============================================================================
# Custom Functions
functions = list.files("Functions")
for(i in 1:length(functions)){
filename = paste0("Functions/",functions[i])
source(filename)
}
allFiles = list.files("Data",pattern="\\.SDF$")
hitlists = allFiles[grep("hitlist",allFiles)]
queries = allFiles[grep("single",allFiles)]
# Section 1: Identifying potential core structure
numSearches = length(hitilsts)
numEpsilons = length(epsilons)
Results = NULL
hitlists
i = 1
hitlist = read.SDFset(hitlists[i])
hitlist = read.SDFset(paste0("Data/",hitlists[i]))
# calculate "overlap" matrix # TIME CONSUMING COMPUTATION
hitlist.overlap <- overlap.matrix(hitlist)
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
hitlist
hitlist[[1]]
hitlists[1]
Scores = rep(900,length(hitlist))
Scores
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
# Prototype code for identifying "core" structure from an
# MS Library search hit list. Code used for preparing ASMS results 2022 and
# working paper titled "Identifying the core structure of an analyte using
# ms library search results: a clustering-based approach" by Erisman & Moorthy.
#
# Developers:  EPE; edward.erisman@nist.gov
#              ASM; arun.moorthy@nist.gov
#
# Date: March 16th, 2022
# Revision Date: June 15th, 2022
# ==============================================================================
# Clear Work Space
rm(list=ls())
# USER INPUTS
epsilons = c(0)     # cluster neighborhood size (can test more neighborhoods by building out epsilons list)
maxHits = 100;      # max hits used in clustering
# ==============================================================================
# External Packages
library(ChemmineR)  # For Plotting SDF
library(fmcsR)      # For computing MCS
library(dbscan)     # For performing db clustering
library(data.table) # For creating data tables and storing results
# ==============================================================================
# Custom Functions
functions = list.files("Functions")
for(i in 1:length(functions)){
filename = paste0("Functions/",functions[i])
source(filename)
}
# ==============================================================================
# Reading in Hit Lists and query files for analysis
allFiles = list.files("Data",pattern="\\.SDF$")
hitlists = allFiles[grep("hitlist",allFiles)]
queries = allFiles[grep("single",allFiles)]
## Main Script =================================================================
# The code can be broken into two parts. In the first section, given a hit list,
# we identify a potential core structure (if possible). In the second section,
# given a core structure and the analyte's known structure, we assess the quality
# of the predicted core structure.
# Section 1: Identifying potential core structure
numSearches = length(hitlists)
numEpsilons = length(epsilons)
Results = NULL
stime <- system.time({
for(i in 1:numSearches){
hitlist = read.SDFset(paste0("Data/",hitlists[i])) # structures from hit list
Scores = rep(900,length(hitlist)) ## Stand in because provided hit list structure does not have scores. For full example with
## Hit list scores using output from MS Pepsearch, request "CoreFinder_ASMS_Poster.zip"
## from Ed or Arun.
# calculate "overlap" matrix # TIME CONSUMING COMPUTATION
hitlist.overlap <- overlap.matrix(hitlist)
cores = NULL;
hitlist.clusters = NULL;
core.clusters = NULL;
for(k in 1:length(epsilons)){
# cluster the data based on structural similarity #
hitlist.clusters[[k]] = hitlist.cluster = c(find.cluster(hitlist.overlap,epsilons[k]))
# identify the cluster to be used in finding core: (1) cluster with most elements, (2) cluster with highest average mf, (3) cluster with highest max mf #
core.clusters[[k]] = core.cluster = c(det.core.cluster(hitlist.cluster,Scores,"MaxAvgMFInCluster"))
# find core #
if(length(core.cluster)>1){
cores[[k]] = find.core(hitlist[core.cluster])
} else {
cores[[k]] = "NA"
}
}
Results[[i]] = list(HITLIST.SIZE = length(hitlist), CLUSTERS = hitlist.clusters, CORE.CLUSTERS = core.clusters, CORES = cores)
}
})[3]
# Prototype code for identifying "core" structure from an
# MS Library search hit list. Code used for preparing ASMS results 2022 and
# working paper titled "Identifying the core structure of an analyte using
# ms library search results: a clustering-based approach" by Erisman & Moorthy.
#
# Developers:  EPE; edward.erisman@nist.gov
#              ASM; arun.moorthy@nist.gov
#
# Date: March 16th, 2022
# Revision Date: June 15th, 2022
# ==============================================================================
# Clear Work Space
rm(list=ls())
# LOAD External Packages
library(ChemmineR)  # For Plotting SDF
library(fmcsR)      # For computing MCS
library(dbscan)     # For performing db clustering
library(data.table) # For creating data tables and storing results
# ==============================================================================
# USER INPUTS
hitlist = read.SDFset("ExampleData/408 hitlist.SDF") # structures from hit list
query = read.SDFset("ExampleData/408 single.SDF") # structure of query
epsilons = c(0)     # cluster neighborhood size (can test up to 4 neighborhood
# sizes by building out epsilons list)
maxHits = 100;      # max hits used in clustering
# ==============================================================================
# External Packages
library(ChemmineR)  # For Plotting SDF
library(fmcsR)      # For computing MCS
library(dbscan)     # For performing db clustering
library(data.table) # For creating data tables and storing results
# ==============================================================================
# Custom Functions
functions = list.files("Functions")
for(i in 1:length(functions)){
filename = paste0("Functions/",functions[i])
source(filename)
}
## Main Script =================================================================
# The code can be broken into two parts. In the first section, given a hit list,
# we identify a potential core structure (if possible). In the second section,
# given a core structure and the query's known structure, we assess the quality
# of the predicted core structure.
# Section 1: Identifying potential core structure
numSearches = length(hitlists)
numEpsilons = length(epsilons)
Results = NULL
stime <- system.time({
Scores = rep(900,length(hitlist)) ## Stand in because provided hit list structure does not have scores. For full example with
## Hit list scores using output from MS Pepsearch, request "CoreFinder_ASMS_Poster.zip"
## from Ed or Arun.
# calculate "overlap" matrix # TIME CONSUMING COMPUTATION
hitlist.overlap <- overlap.matrix(hitlist)
cores = NULL;
hitlist.clusters = NULL;
core.clusters = NULL;
for(k in 1:length(epsilons)){
# cluster the data based on structural similarity #
hitlist.clusters[[k]] = hitlist.cluster = c(find.cluster(hitlist.overlap,epsilons[k]))
# identify the cluster to be used in finding core: (1) cluster with most elements, (2) cluster with highest average mf, (3) cluster with highest max mf #
core.clusters[[k]] = core.cluster = c(det.core.cluster(hitlist.cluster,Scores,"MaxAvgMFInCluster"))
# find core #
if(length(core.cluster)>1){
cores[[k]] = find.core(hitlist[core.cluster])
} else {
cores[[k]] = "NA"
}
}
Results = list(HITLIST.SIZE = length(hitlist), CLUSTERS = hitlist.clusters, CORE.CLUSTERS = core.clusters, CORES = cores)
})[3]
# Prototype code for identifying "core" structure from an
# MS Library search hit list. Code used for preparing ASMS results 2022 and
# working paper titled "Identifying the core structure of an analyte using
# ms library search results: a clustering-based approach" by Erisman & Moorthy.
#
# Developers:  EPE; edward.erisman@nist.gov
#              ASM; arun.moorthy@nist.gov
#
# Date: March 16th, 2022
# Revision Date: June 15th, 2022
# ==============================================================================
# Clear Work Space
rm(list=ls())
# LOAD External Packages
library(ChemmineR)  # For Plotting SDF
library(fmcsR)      # For computing MCS
library(dbscan)     # For performing db clustering
library(data.table) # For creating data tables and storing results
# ==============================================================================
# USER INPUTS
hitlist = read.SDFset("ExampleData/408 hitlist.SDF") # structures from hit list
query = read.SDFset("ExampleData/408 single.SDF") # structure of query
length(hitlist)
# ==============================================================================
# USER INPUTS
hitlist = read.SDFset("ExampleData/408 hitlist.SDF")[1:10] # structures from hit list
length(hitlist)
query = read.SDFset("ExampleData/408 single.SDF") # structure of query
epsilons = c(0)     # cluster neighborhood size (can test up to 4 neighborhood
maxHits = 100;      # max hits used in clustering
# ==============================================================================
# Custom Functions
functions = list.files("Functions")
for(i in 1:length(functions)){
filename = paste0("Functions/",functions[i])
source(filename)
}
# Section 1: Identifying potential core structure
numEpsilons = length(epsilons)
Results = NULL
Scores = rep(900,length(hitlist)) ## Stand in because provided hit list structure does not have scores. For full example with
# calculate "overlap" matrix # TIME CONSUMING COMPUTATION
hitlist.overlap <- overlap.matrix(hitlist)
cores = NULL;
hitlist.clusters = NULL;
core.clusters = NULL;
for(k in 1:length(epsilons)){
# cluster the data based on structural similarity #
hitlist.clusters[[k]] = hitlist.cluster = c(find.cluster(hitlist.overlap,epsilons[k]))
# identify the cluster to be used in finding core: (1) cluster with most elements, (2) cluster with highest average mf, (3) cluster with highest max mf #
core.clusters[[k]] = core.cluster = c(det.core.cluster(hitlist.cluster,Scores,"MaxAvgMFInCluster"))
# find core #
if(length(core.cluster)>1){
cores[[k]] = find.core(hitlist[core.cluster])
} else {
cores[[k]] = "NA"
}
}
Results = list(HITLIST.SIZE = length(hitlist), CLUSTERS = hitlist.clusters, CORE.CLUSTERS = core.clusters, CORES = cores)
Results
plot(RESULTS$CORES)
plot(Results$CORES[[1]])
j = 1
cat(length(Results[[i]]$CORE.CLUSTERS[[j]])) # cluster size to create core
i
i = 1
cat(length(Results[[i]]$CORE.CLUSTERS[[j]])) # cluster size to create core
Results[[1]]
cat(length(Results$CORE.CLUSTERS[[j]])) # cluster size to create core
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results[[i]]$CORES[[j]]
cat(MF(core,addH=TRUE))
cat(" \t ")
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0(round(keyMCSstat,3)," \t "))
keyMCSstat = stats(keyMCS)[4];
cat(round(keyMCSstat,3))
}
cat(paste0("Core MF: ", MF(core,addH=TRUE)))
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE)))
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query))
}
cat("\n\n")
} # end for j
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query),labels=c("core","query"))
}
cat("\n\n")
} # end for j
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query),title=c("core","query"))
}
cat("\n\n")
} # end for j
plot(c(core,query),names=c("core","query"))
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query),names=c("core","query"))
}
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query),name=c("core","query"))
}
cat("\n\n")
} # end for j
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("NA \t NA \t NA")
} else {
core = Results$CORES[[j]]
cat(paste0("Core MF: ", MF(core,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query),name=c("core","query"))
}
cat("\n\n")
} # end for j
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
warnings()
dev.off()
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
Results
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("No core identified with selected neighborhood range. \n")
} else {
cat(paste0("Results using neighboorhood region epsilon = ",epsilons[j],"\n"))
core = Results$CORES[[j]]
cat(paste0("Core Mol Form: ", MF(core,addH=TRUE),"\n"))
cat(paste0("Query Mol Form: ", MF(query,addH=TRUE),"\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient (core/query): ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient (core/query): ",round(keyMCSstat,3)," \n"))
plot(c(core,query))
}
cat("\n\n")
} # end for j
for(j in 1:numEpsilons){
if(class(Results$CORES[[j]])!="SDFset"){
cat("No core identified with selected neighborhood range. \n")
} else {
cat(paste0("Results using neighboorhood region epsilon = ",epsilons[j],"\n"))
core = Results$CORES[[j]]
cat(paste0("Core Mol Form: ", MF(core,addH=TRUE),"\n"))
cat(paste0("Query Mol Form: ", MF(query,addH=TRUE),"\n\n"))
keyMCS = fmcs(core,query);
keyMCSstat = stats(keyMCS)[5];
cat(paste0("Overlap coefficient: ",round(keyMCSstat,3)," \n"))
keyMCSstat = stats(keyMCS)[4];
cat(paste0("Tanimoto coefficient: ",round(keyMCSstat,3)," \n"))
plot(c(core,query))
}
cat("\n\n")
} # end for j
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
source("~/Documents/Research/2022/ASMS_Erisman/CoreFinder_ASMS_Poster/main.R")
Results
